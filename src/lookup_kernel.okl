// Original OpenMP : 12.1 - 12.2 sec

// IB(A,B) -> Inner Dim = A, Batch Dim = B

//---[ OKL:OpenMP ]---------------------
// OKL:OpenMP        : 19.7 sec
// sqrt(E)           : 17.4 sec
// calculate_sig_T   : 16.4 sec
// Manual div/mult   : 16.1 sec
// Optimization Flags: 13.4 sec
// Current IB(64,32) : 12.5 - 13.7 sec (large range ...)
// Expand complex    : 12.1 - 12.4
//======================================

//---[ OKL:CUDA ]-----------------------
// IB(256,64)      : 15.7 sec
// Remove registers: 15.2 sec
// Window *        : 14.7 sec
//======================================

// Verification: 3009.471282

#if !OCCA_USING_CUDA
#  define __ldg(PTR) *(PTR)
#endif

typedef struct{
	double real;
	double imag;
} Complex;

typedef struct{
	//complex double MP_EA;
	//complex double MP_RT;
	//complex double MP_RA;
	//complex double MP_RF;
	Complex MP_EA;
	Complex MP_RT;
	Complex MP_RA;
	Complex MP_RF;
	short int l_value;
} Pole;

typedef struct{
	double T;
	double A;
	double F;
	int start;
	int end;
} Window;

const double dist[12] = {
	0.140,	// fuel
	0.052,	// cladding
	0.275,	// cold, borated water
	0.134,	// hot, borated water
	0.154,	// RPV
	0.064,	// Lower, radial reflector
	0.066,	// Upper reflector / top plate
	0.055,	// bottom plate
	0.008,	// bottom nozzle
	0.015,	// top nozzle
	0.025,	// top of fuel assemblies
	0.013 	// bottom of fuel assemblies
};

const double distSum[11] = {
	0.140,
	0.192,
	0.467,
	0.601,
	0.755,
	0.819,
	0.885,
	0.94,
	0.948,
	0.963,
	0.988
};

occaFunction double rn(unsigned long int * seed) {
	const unsigned long int a  = 16807;
	const unsigned long int m  = 2147483647;
	const unsigned long int n1 = ( a * (*seed) ) % m;

	*seed = n1;

	return ((double) n1 / m);
}

occaFunction int pick_mat( unsigned long int * seed ) {
	// I have a nice spreadsheet supporting these numbers. They are
	// the fractions (by volume) of material in the core. Not a
	// *perfect* approximation of where XS lookups are going to occur,
	// but this will do a good job of biasing the system nonetheless.

	// Also could be argued that doing fractions by weight would be
	// a better approximation, but volume does a good enough job for now.

	//double roll = (double) rand() / (double) RAND_MAX;
	const double roll = rn(seed);

	// makes a pick based on the distro
	for( int i = 0; i < 11; i++ ){
		if(roll < distSum[i])
			return i;
	}

	return 11;
}

//occaFunction void calculate_sig_T( int nuc, double E, int numL, double * pseudo_K0RS, complex double * sigTfactors )
occaFunction inline void calculate_sig_T( int nuc, double sqrtE, int numL, const double * pseudo_K0RS, Complex * sigTfactors){

	for(int i = 0; i < numL; ++i){
    const double r_K0RS = __ldg(&pseudo_K0RS[nuc*numL + i]);

    const double phi  = r_K0RS * sqrtE;
    const double phi2 = phi*phi;

    double theta = phi;

    if( i == 2 )
      theta = (3.0 * phi / (3.0 - phi2));
    else if( i == 3 )
      theta = (phi*(15.0-phi2)/(15.0-6.0*phi2));

    //   cos(2*(phi - atan(theta)))
    // - sin(2*(phi - atan(theta))
    // + Wolfram Alpha

    const double cos2Phi = cos(2.0*phi);
    const double sin2Phi = sin(2.0*phi);

    const double factor = 1.0/(1.0 + theta*theta);
    const double theta2 = (theta*theta);

    sigTfactors[i].real =  factor*((1 - theta2)*cos2Phi + 2.0*theta*sin2Phi);
    sigTfactors[i].imag = -factor*((1 - theta2)*sin2Phi - 2.0*theta*cos2Phi);
  }
}

occaFunction inline Complex cadd(Complex a, Complex b)
{
	Complex c;
	c.real = a.real + b.real;
	c.imag = a.imag + b.imag;
	return c;
}

occaFunction inline Complex csubtract(Complex a, Complex b)
{
	Complex c;
	c.real = a.real - b.real;
	c.imag = a.imag - b.imag;
	return c;
}

occaFunction inline void cmultiply(Complex &c, const Complex &a, const Complex &b)
{
	c.real = a.real*b.real - a.imag*b.imag;
	c.imag = a.imag*b.real + a.real*b.imag;
}

occaFunction inline void cdivide(Complex &c, const Complex a, const Complex b)
{
  const double invNorm_ = 1.0/(b.real*b.real + b.imag*b.imag);

	c.real = invNorm_*(a.real*b.real + a.imag*b.imag);
	c.imag = invNorm_*(a.imag*b.real - a.real*b.imag);
}

occaKernel void lookup_kernel(const Pole   * const restrict poles,
                              const Window * const restrict windows,
                              const double * const restrict pseudo_K0RS,
                              const int    * const restrict n_poles,
                              const int    * const restrict n_windows,
                              const int    * const restrict poles_idx,
                              const int    * const restrict windows_idx,
                              const int    * const restrict num_nucs,
                              const int    * const restrict mats,
                              const int    * const restrict mats_idx,
                              const double * const restrict concs,
                              const int lookups,
                              const int n_nuclides,
                              const int avg_n_poles,
                              const int avg_n_windows,
                              const int numL,
                              double * restrict V_sums){

	for(int outer_id = 0; outer_id < outer_dim; ++outer_id; outer0) {

		for(int inner_id = 0; inner_id < inner_dim; ++inner_id; inner0) {
			// Variables declared in the scope of an InnerFor loop are register variables
			const int global_id = outer_id*inner_dim + inner_id;

      //complex double * sigTfactors = (complex double *) malloc(numL * sizeof(complex double));
      //Complex * sigTfactors = (Complex *) malloc(numL * sizeof(Complex));
      Complex sigTfactors[4]; //hardcoding to 4 for now...

      double inner_V_sum[4];

      inner_V_sum[0] = 0;
      inner_V_sum[1] = 0;
      inner_V_sum[2] = 0;
      inner_V_sum[3] = 0;

      for(int batch_id = 0; batch_id < batch_dim; ++batch_id){

        const int lookup_id = global_id*batch_dim + batch_id;

        unsigned long int seed = lookup_id*10000 + 1;

        if(lookup_id < lookups){

          // Randomly pick energy and material
          const int mat  = pick_mat(&seed);
          const double E = rn(&seed);

          const double sqrtE = sqrt(E);
          const double invE  = (1.0 / E);

          const int nucs_idx = num_nucs[mat];
          const int mat_idx  = mats_idx[mat];

          // for nuclide in mat
          for(int j = 0; j < nucs_idx; ++j){
            const int nuc     = __ldg(&mats[mat_idx + j]);
            const double conc = __ldg(&concs[mat_idx + j]);

            const int nuc_pole    = __ldg(&poles_idx[nuc]);
            const int nuc_windows = __ldg(&n_windows[nuc]);
            const int nuc_window  = __ldg(&windows_idx[nuc]);

            // MicroScopic XS's to Calculate
            double sigT, sigA, sigF, sigE;

            // Calculate Window Index
            const int window = (E * nuc_windows) - (1.0 <= E);

            // Calculate sigTfactors
            calculate_sig_T(nuc, sqrtE, numL, pseudo_K0RS, sigTfactors); // 9.2 sec

            // Calculate contributions from window "background" (i.e., poles outside window (pre-calculated)
            const Window *w = &(windows[nuc_window + window]);

            sigT = E * w->T;
            sigA = E * w->A;
            sigF = E * w->F;

            // Loop over Poles within window, add contributions
            for(int k = w->start; k < w->end; k++){

              const Pole pole = poles[nuc_pole + k];

              Complex PSIIKI, CDUM, tmp;

              PSIIKI.real = 0.0;
              PSIIKI.imag = 1.0;

              tmp.real = pole.MP_EA.real - sqrtE;
              tmp.imag = pole.MP_EA.imag;

              // PSIIKI = cdivide(PSIIKI, tmp);
              const double tmpNorm = 1.0/(tmp.real*tmp.real + tmp.imag*tmp.imag);

              PSIIKI.real = tmpNorm * tmp.imag;
              PSIIKI.imag = tmpNorm * tmp.real;

              // CDUM = cdivide(PSIIKI, tmp);
              CDUM.real = invE * PSIIKI.real;
              CDUM.imag = invE * PSIIKI.imag;

              // real(pole.MP_RT * sigTfactors[pole.l_value] * CDUM);
              cmultiply(tmp, pole.MP_RT, sigTfactors[pole.l_value]);
              sigT += (tmp.real * CDUM.real -
                       tmp.imag * CDUM.imag);

              // real(pole.MP_RA * CDUM);
              sigA += (pole.MP_RA.real * CDUM.real -
                       pole.MP_RA.imag * CDUM.imag);

              // real(pole.MP_RF * CDUM);
              sigF += (pole.MP_RF.real * CDUM.real -
                       pole.MP_RF.imag * CDUM.imag);
            }

            sigE = sigT - sigA;

            inner_V_sum[0] += sigT * conc;
            inner_V_sum[1] += sigA * conc;
            inner_V_sum[2] += sigF * conc;
            inner_V_sum[3] += sigE * conc;
          } // Materials loop
        }
			} // Lookups loop

      V_sums[4*global_id + 0] = inner_V_sum[0];
      V_sums[4*global_id + 1] = inner_V_sum[1];
      V_sums[4*global_id + 2] = inner_V_sum[2];
      V_sums[4*global_id + 3] = inner_V_sum[3];
		} // inner0
		//free(sigTfactors);
	} // outer0
}

occaKernel void lookup_kernel_doppler(const Pole   * const restrict poles,
                                      const Window * const restrict windows,
                                      const double * const restrict pseudo_K0RS,
                                      const int    * const restrict n_poles,
                                      const int    * const restrict n_windows,
                                      const int    * const restrict poles_idx,
                                      const int    * const restrict windows_idx,
                                      const int    * const restrict num_nucs,
                                      const int    * const restrict mats,
                                      const int    * const restrict mats_idx,
                                      const double * const restrict concs,
                                      const int lookups,
                                      const int n_nuclides,
                                      const int avg_n_poles,
                                      const int avg_n_windows,
                                      const int numL,
                                      double * restrict V_sums){

	for(int outer_id = 0; outer_id < outer_dim; ++outer_id; outer0) {

		for(int inner_id = 0; inner_id < inner_dim; ++inner_id; inner0) {
			// Variables declared in the scope of an InnerFor loop are register variables
			const int global_id = outer_id*inner_dim + inner_id;
			unsigned long int seed = global_id*10000 + 1;

      //complex double * sigTfactors = (complex double *) malloc(numL * sizeof(complex double));
      //Complex * sigTfactors = (Complex *) malloc(numL * sizeof(Complex));
      Complex sigTfactors[4]; //hardcoding to 4 for now...

      double inner_V_sum[4];

			inner_V_sum[0] = 0;
			inner_V_sum[1] = 0;
			inner_V_sum[2] = 0;
			inner_V_sum[3] = 0;

			if(global_id < lookups){

				// Randomly pick energy and material
				const int mat  = pick_mat(&seed);
				const double E = rn(&seed);

				const int nucs_idx = num_nucs[mat];
				const int mat_idx  = mats_idx[mat];

				// for nuclide in mat
				for(int j = 0; j < nucs_idx; j++){
					const int nuc     = mats[mat_idx + j];
          const double conc = concs[mat_idx + j];

          const int nuc_windows = n_windows[nuc];

					// MicroScopic XS's to Calculate
					double sigT;
					double sigA;
					double sigF;
					double sigE;

					// Calculate Window Index
					const double spacing = 1.0 / ((double) nuc_windows);

					int window = (int) (E / spacing);

					if(window == nuc_windows)
						--window;

					// Calculate sigTfactors
					calculate_sig_T(nuc, E, numL, pseudo_K0RS, sigTfactors);

					// Calculate contributions from window "background" (i.e., poles outside window (pre-calculated)
					const Window w = windows[windows_idx[nuc] + window];
					sigT = E * w.T;
					sigA = E * w.A;
					sigF = E * w.F;

					const double dopp = 0.5;

					// Loop over Poles within window, add contributions
					for(int k = w.start; k < w.end; k++){
						Pole pole = poles[poles_idx[nuc] + k];

						// Prep Z
						//double Z = (E - creal(pole.MP_EA)) * dopp;
						double Z = (E - pole.MP_EA.real) * dopp;

						// Evaluate Fadeeva Function
						//double faddeeva = exp(-1.0 * creal(Z * Z)) * erfc(-1.0 * creal(Z * I));
						double faddeeva = exp(-1.0 * (Z * Z)) * erfc(-1.0 * 0.0);

						// Update W
						//sigT += creal( pole.MP_RT * faddeeva * sigTfactors[pole.l_value] );
						//sigA += creal( pole.MP_RA * faddeeva);
						//sigF += creal( pole.MP_RF * faddeeva);
						Complex c_faddeeva, tmp, t, a, f;

						c_faddeeva.real = faddeeva;
						c_faddeeva.imag = 0;

            cmultiply(tmp   , pole.MP_RT, c_faddeeva);
            cmultiply(t, tmp, sigTfactors[pole.l_value]);
            cmultiply(a     , pole.MP_RA, c_faddeeva);
            cmultiply(f     , pole.MP_RF, c_faddeeva);

						sigT += t.real;
						sigA += a.real;
						sigF += f.real;
					}

					sigE = sigT - sigA;

					inner_V_sum[0] += sigT * conc;
					inner_V_sum[1] += sigA * conc;
					inner_V_sum[2] += sigF * conc;
					inner_V_sum[3] += sigE * conc;
				} // Materials loop

				V_sums[4*global_id + 0] = inner_V_sum[0];
				V_sums[4*global_id + 1] = inner_V_sum[1];
				V_sums[4*global_id + 2] = inner_V_sum[2];
				V_sums[4*global_id + 3] = inner_V_sum[3];
			} // Lookups loop
		} // inner0
		//free(sigTfactors);
	} // outer0
}