typedef struct{
	double real;
	double imag;
} Complex;

typedef struct{
	//complex double MP_EA;
	//complex double MP_RT;
	//complex double MP_RA;
	//complex double MP_RF;
	Complex MP_EA;
	Complex MP_RT;
	Complex MP_RA;
	Complex MP_RF;
	short int l_value;
} Pole;

typedef struct{
	double T;
	double A;
	double F;
	int start;
	int end;
} Window;

const double dist[12] = {
  0.140,	// fuel
  0.052,	// cladding
  0.275,	// cold, borated water
  0.134,	// hot, borated water
  0.154,	// RPV
  0.064,	// Lower, radial reflector
  0.066,	// Upper reflector / top plate
  0.055,	// bottom plate
  0.008,	// bottom nozzle
  0.015,	// top nozzle
  0.025,	// top of fuel assemblies
  0.013 	// bottom of fuel assemblies
};

const double distSum[11] = {
  0.140,
  0.192,
  0.467,
  0.601,
  0.755,
  0.819,
  0.885,
  0.94,
  0.948,
  0.963,
  0.988
};

occaFunction double rn(unsigned long int * seed) {
  const unsigned long int a  = 16807;
  const unsigned long int m  = 2147483647;
  const unsigned long int n1 = ( a * (*seed) ) % m;

  *seed = n1;

  return ((double) n1 / m);
}

occaFunction int pick_mat( unsigned long int * seed ) {
  // I have a nice spreadsheet supporting these numbers. They are
  // the fractions (by volume) of material in the core. Not a
  // *perfect* approximation of where XS lookups are going to occur,
  // but this will do a good job of biasing the system nonetheless.

  // Also could be argued that doing fractions by weight would be
  // a better approximation, but volume does a good enough job for now.

  //double roll = (double) rand() / (double) RAND_MAX;
  const double roll = rn(seed);

  // makes a pick based on the distro
  for( int i = 0; i < 11; i++ ){
    if(roll < distSum[i])
      return i;
  }

  return 11;
}

//occaFunction void calculate_sig_T( int nuc, double E, int numL, double * pseudo_K0RS, complex double * sigTfactors )
occaFunction void calculate_sig_T( int nuc, double E, int numL, double * pseudo_K0RS, Complex * sigTfactors)
{
	double phi;

	for( int i = 0; i < numL; i++ )
	{
		phi = pseudo_K0RS[nuc*numL + i] * sqrt(E);

		if( i == 1 )
			phi -= - atan( phi );
		else if( i == 2 )
			phi -= atan( 3.0 * phi / (3.0 - phi*phi));
		else if( i == 3 )
			phi -= atan(phi*(15.0-phi*phi)/(15.0-6.0*phi*phi));

		phi *= 2.0;

		//sigTfactors[i] = cos(phi) - sin(phi) * _Complex_I;
		sigTfactors[i].real = cos(phi);
		sigTfactors[i].imag =  -sin(phi);
	}
}

occaFunction Complex cadd(Complex a, Complex b)
{
	Complex c;
	c.real = a.real + b.real;
	c.imag = a.imag + b.imag;
	return c;
}

occaFunction Complex csubtract(Complex a, Complex b)
{
	Complex c;
	c.real = a.real - b.real;
	c.imag = a.imag - b.imag;
	return c;
}

occaFunction Complex cmultiply(Complex a, Complex b)
{
	Complex c;
	c.real = a.real*b.real - a.imag*b.imag;
	c.imag = a.imag*b.real + a.real*b.imag;
	return c;
}

occaFunction Complex cdivide(Complex a, Complex b)
{
	Complex c;
	c.real = (a.real*b.real + a.imag*b.imag)/(b.real*b.real + b.imag*b.imag);
	c.imag = (a.imag*b.real - a.real*b.imag)/(b.real*b.real + b.imag*b.imag);
	return c;
}

occaKernel void lookup_kernel(
     const Pole * const restrict poles,
     const Window * const restrict windows,
     double * pseudo_K0RS,
     const int * const restrict n_poles,
     const int * const restrict n_windows,
     const int * const restrict poles_idx,
     const int * const restrict windows_idx,
     const int * const restrict num_nucs,
     const int * const restrict mats,
     const int * const restrict mats_idx,
     const double * const restrict concs,
     const int lookups,
     const int n_nuclides,
     const int avg_n_poles,
     const int avg_n_windows,
     const int numL,
     double * restrict V_sums)
{
	for(int outer_id=0; outer_id<outer_dim; ++outer_id; outer0) {

		double inner_V_sum[4];
		//complex double * sigTfactors = (complex double *) malloc(numL * sizeof(complex double));
		Complex * sigTfactors = (Complex *) malloc(numL * sizeof(Complex));

		for (int inner_id=0; inner_id<inner_dim; ++inner_id; inner0) {

			// Variables declared in the scope of an InnerFor loop are register variables
			const int global_id = outer_id*inner_dim + inner_id;
			unsigned long int seed = global_id*10000 + 1;

			inner_V_sum[0] = 0;
			inner_V_sum[1] = 0;
			inner_V_sum[2] = 0;
			inner_V_sum[3] = 0;

			if(global_id < lookups){

				// Randomly pick energy and material
				const int mat = pick_mat(&seed);
				const double E = rn(&seed);

				const int nucs_idx = num_nucs[mat];
				const int mat_idx  = mats_idx[mat];

				// for nuclide in mat
				for(int j=0; j<nucs_idx; j++){
					int nuc = mats[mat_idx + j];

					// MicroScopic XS's to Calculate
					double sigT;
					double sigA;
					double sigF;
					double sigE;

					// Calculate Window Index
					double spacing = 1.0 / n_windows[nuc];
					int window = (int) (E / spacing);
					if(window == n_windows[nuc])
						window--;

					// Calculate sigTfactors
					calculate_sig_T(nuc, E, numL, pseudo_K0RS, sigTfactors);

					// Calculate contributions from window "background" (i.e., poles outside window (pre-calculated)
					Window w = windows[windows_idx[nuc] + window];
					sigT = E * w.T;
					sigA = E * w.A;
					sigF = E * w.F;

					// Loop over Poles within window, add contributions
					for(int k=w.start; k<w.end; k++){
						//complex double PSIIKI;
						//complex double CDUM;
						Complex PSIIKI;
						Complex CDUM;
						Pole pole = poles[poles_idx[nuc] + k];
						//PSIIKI = -(0.0 - 1.0 * _Complex_I) / (pole.MP_EA - sqrt(E));
						//CDUM = PSIIKI / E;
						//sigT += creal(pole.MP_RT * CDUM * sigTfactors[pole.l_value]);
						//sigA += creal(pole.MP_RA * CDUM);
						//sigF += creal(pole.MP_RF * CDUM);
						Complex tmp, t, a, f;
						PSIIKI.real = 0.0;
						PSIIKI.imag = 1.0;
						tmp.real = pole.MP_EA.real - sqrt(E);
						tmp.imag = pole.MP_EA.imag;
						PSIIKI = cdivide(PSIIKI, tmp);
						tmp.real = E;
						tmp.imag = 0;
						CDUM = cdivide(PSIIKI, tmp);
						tmp = cmultiply(pole.MP_RT, CDUM);
						t = cmultiply(tmp, sigTfactors[pole.l_value]);
						sigT += t.real;
						a = cmultiply(pole.MP_RA, CDUM);
						sigA += a.real;
						f = cmultiply(pole.MP_RF, CDUM);
						sigF += f.real;
					}

					sigE = sigT - sigA;

					inner_V_sum[0] = sigT;
					inner_V_sum[1] = sigA;
					inner_V_sum[2] = sigF;
					inner_V_sum[3] = sigE;
				} // Materials loop

				V_sums[4*global_id + 0] = inner_V_sum[0];
				V_sums[4*global_id + 1] = inner_V_sum[1];
				V_sums[4*global_id + 2] = inner_V_sum[2];
				V_sums[4*global_id + 3] = inner_V_sum[3];
			} // Lookups loop
		} // inner0
		free(sigTfactors);
	} // outer0
}
